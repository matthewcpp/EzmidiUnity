/**
\file ezmidi.h
Header file for ezmidi public API
*/

#ifndef EZ_MIDI_H
#define EZ_MIDI_H

#define EZMIDI_API


#ifdef __cplusplus
extern "C" {
#endif

typedef struct Ezmidi_Context Ezmidi_Context;

/** Enumerates error messages returned by the library. */
typedef enum {
	/** No error.  The operation was successful. */
	EZMIDI_ERROR_NONE = 0,

	/** The supplied source index is invalid.  */
	EZMIDI_ERROR_INVALID_SOURCE,

	/** The source was unable to be opened.  The device may be busy, or has possibly been disconnected. */
	EZMIDI_ERROR_CONNECTION_FAILED,

	/** The operation faild because there was no active connection. */
	EZMIDI_ERROR_NO_SOURCE_CONNECTED
} Ezmidi_Error;

/** Enumerates the type of all MIDI events. */
typedef enum {
    /** Midi note on/off event */
	EZMIDI_EVENT_NOTE,
} Ezmidi_EventType;

/** Enumerates the specific types of note events. */
typedef enum {
	/** A note is now on. */
	EZMIDI_NOTEEVENT_ON,

	/** A note is now off.  Note: if the controller sends Note on event with velocity of 0, the library will expose it as a note off event. */
	EZMIDI_NOTEEVENT_OFF
} Ezmidi_NoteEventId;

/** Structure representing a MIDI note event. */
typedef struct {
	/** The event type.  This will be EZMIDI_EVENT_NOTE */
	Ezmidi_EventType type;

	/** Indicates the type of note event: On / OFF. */
	Ezmidi_NoteEventId detail;

	/** The MIDI note number. */
	int note;

	/** The note's velocity value. This value will range between 0 and 127. */
	int velocity;

	/** the note's channel. */
	int channel;
} Ezmidi_NoteEvent;

/**
Union consisting of all possible midi event types the library can respond to.
*/
typedef union {
	Ezmidi_EventType type;
	Ezmidi_NoteEvent note_event;
} Ezmidi_Event;
    
/** Log function callback.
\param message informational message generated by the library
\param user_data user supplied callback data
*/
typedef void(*Ezmidi_LogFunc)(const char* message, void* user_data);
   
/**
Structure containing configuration settings for a ezmidi context
*/
typedef struct {
	/** Callback function for log messages */
    Ezmidi_LogFunc log_func;

	/** User data that will be passed to all callback functions. */
	void* user_data;
} Ezmidi_Config;

/**
Creates a new ezmidi context.
\param config pointer to a configuration object that will control various library settings.  If this parameter is null default configuration options will be used.
\returns pointer to a new context.  In the event of an error, this function will return null.
*/
EZMIDI_API Ezmidi_Context* ezmidi_create(Ezmidi_Config* config);

/**
Closes any active connection held by the context and frees all associated system resources.
\param context Ezmidi context pointer.
*/
EZMIDI_API void ezmidi_destroy(Ezmidi_Context* context);

/**
Initializes a config object with default values.
\param config Configuration object which will be initialized with default values.
*/
EZMIDI_API void ezmidi_config_init(Ezmidi_Config* config);

/**
Gets the number of MIDI input sources that are connected to the system.
Note: all sources may not be able be connected to.  For example a device may be in use by another application.
\param context Ezmidi context pointer.
\returns Number of MIDI input sources connected to the system.
*/
EZMIDI_API int ezmidi_get_source_count(Ezmidi_Context* context);

/**
Gets the name of an imput source.  The exact name of the device returned by this function may vary depending on platform.
In the event that this function returns a string, its memory is owned by the library and does not need to be freed by the caller.
This pointer, however, is only valid until the next ezmidi API call.  If this data needs to be persisted, it should be copied into your own data structure.
\param context Ezmidi context pointer.
\param source Index of the source to get the name of.
\returns Source name string if source is a valid index.  If source is invalid or a name could not be retrieved, this function will return null.
*/
EZMIDI_API const char* ezmidi_get_source_name(Ezmidi_Context* context, int source);

/**
Connects to the midi input source with a given index.
\param context Ezmidi context pointer.
\param source index of the source to connect to.
*/
EZMIDI_API Ezmidi_Error ezmidi_connect_source(Ezmidi_Context* context, int source);

/**
Closes the active connection for the supplied context.
\param context Ezmidi context pointer.
\returns Error code indicating the result of the operation.
*/
EZMIDI_API Ezmidi_Error ezmidi_disconnect_source(Ezmidi_Context* context);

/**
Gets whether a context has a connected source.
\param context Ezmidi context pointer.
\returns non zero value if a source is connected.  If no source is connected 0 is returned.
*/
EZMIDI_API int ezmidi_has_source_connected(Ezmidi_Context* context);

/**
Pumps the event queue for the next pending event.  Events are processed in a FIFO manner.
\param context Ezmidi context pointer.
\param event Pointer to an event object that will receive event data for next pending event.
\returns Non zero value if an event was processed, otherwise zero.
*/
EZMIDI_API int ezmidi_get_next_event(Ezmidi_Context* context, Ezmidi_Event* event);

#ifdef __cplusplus
}
#endif
    
#endif

#ifdef EZMIDI_IMPLEMENTATION

// **********
// midi.h
// **********
#ifndef EZMIDI_MIDI_H
#define EZMIDI_MIDI_H

namespace Midi {

// reference: https://www.midi.org/specifications-old/item/table-2-expanded-messages-list-status-bytes
enum Status {
	NoteOffChannel1 = 128,
	NoteOffChannel16 = 143,
	NoteOnChannel1 = 144,
	NoteOnChannel16 = 159,
	TimingClock = 248,
	ActiveSensing = 254
};

inline bool shouldFilterEvent(int status) {
	return status == Status::ActiveSensing || status == Status::TimingClock;
}
	
inline bool isNoteEvent(int status) {
	return status >= Status::NoteOffChannel1 && status <= Status::NoteOnChannel16;
}

}

#endif

// **********
// message_processor.h
// **********
#ifndef EZMIDI_MESSAGE_PROCESSOR_H
#define EZMIDI_MESSAGE_PROCESSOR_H


#include <queue>
#include <mutex>
#include <cstdint>

namespace ezmidi {

/**
Processes and filters raw MIDI messages.
Relevant messages are queued as Ezmidi_Event event objects.
This class is designed to be thread safe.
*/
class MessageProcessor{
public:
    void processMidiMessage(const uint8_t* data);
	int getNextEvent(Ezmidi_Event& event);
    
private:
    void processNoteEvent(const uint8_t* data);
	
private:
	std::queue<Ezmidi_Event> events_;
	std::mutex mutex_;
};
	
}

#endif

// **********
// common.cpp
// **********

void ezmidi_config_init(Ezmidi_Config* config)
{
    config->log_func = nullptr;
	config->user_data = nullptr;
}

// **********
// message_processor.cpp
// **********

namespace ezmidi {
    
void MessageProcessor::processMidiMessage(const uint8_t* data)
{
    std::lock_guard<std::mutex> lock(mutex_);

    int midiStatus = data[0];
        
    if (Midi::shouldFilterEvent(midiStatus)) {
        return;
    }
    else if (Midi::isNoteEvent(midiStatus)) {            
        processNoteEvent(data);
    }
}
	
void MessageProcessor::processNoteEvent(const uint8_t* data)
{
	int status = data[0];

	Ezmidi_Event event;
	event.note_event.type = Ezmidi_EventType::EZMIDI_EVENT_NOTE;
	event.note_event.note = data[1];
	event.note_event.velocity = data[2];
	
	// Note: note on with a velocity of 0 means that the note was released!
	if (status >= Midi::Status::NoteOnChannel1 && status <= Midi::Status::NoteOnChannel16) {
		event.note_event.detail = event.note_event.velocity > 0 ? EZMIDI_NOTEEVENT_ON : EZMIDI_NOTEEVENT_OFF;
		event.note_event.channel = status - Midi::Status::NoteOnChannel1 + 1;
	}
	else{
		event.note_event.detail = EZMIDI_NOTEEVENT_OFF;
		event.note_event.channel = status - Midi::Status::NoteOffChannel1 + 1;
	}
	
	events_.push(event);
}

int MessageProcessor::getNextEvent(Ezmidi_Event& event)
{
    std::lock_guard<std::mutex> lock(mutex_);

	if (events_.empty()) {
		return 0;
	}

	event = events_.front();
	events_.pop();
	return 1;
}
	
}

#ifdef _WIN32

// **********
// windows.cpp
// **********

#include <windows.h>

#include <string>

struct EzmidiWindows
{
	HMIDIIN input_handle = NULL;
	ezmidi::MessageProcessor message_processor;
	std::string return_data;
	Ezmidi_Config config;
};

static void CALLBACK windows_midi_in_proc(HMIDIIN input_handle, UINT message_type, DWORD_PTR instance_data, DWORD_PTR message, DWORD timestamp)
{
	auto midi_lib = reinterpret_cast<EzmidiWindows*>(instance_data);
	const char* packet = reinterpret_cast<const char*>(&message);
	
	if (message_type != MIM_DATA) return;

	midi_lib->message_processor.processMidiMessage(reinterpret_cast<const unsigned char *>(&message));
}

Ezmidi_Error close_existing_connection(EzmidiWindows* midi_lib)
{
	if (midi_lib->input_handle == NULL) {
		return EZMIDI_ERROR_NO_SOURCE_CONNECTED;
	}

	midiInReset(midi_lib->input_handle);
	midiInStop(midi_lib->input_handle);
	midiInClose(midi_lib->input_handle);

	midi_lib->input_handle = NULL;

	return EZMIDI_ERROR_NONE;
}

Ezmidi_Context* ezmidi_create(Ezmidi_Config* config)
{
	auto midi_lib = new EzmidiWindows{};

	if (config)
		midi_lib->config = *config;
	else
		ezmidi_config_init(&midi_lib->config);

	return reinterpret_cast<Ezmidi_Context*>(midi_lib);
}

void ezmidi_destroy(Ezmidi_Context* context)
{
	auto midi_lib = reinterpret_cast<EzmidiWindows*>(context);
    close_existing_connection(midi_lib);

	delete midi_lib;
}

int ezmidi_get_source_count(Ezmidi_Context* /* context */)
{
	return static_cast<int>(midiInGetNumDevs());
}

const char* ezmidi_get_source_name(Ezmidi_Context* context, int source_index)
{
	int num_devices = static_cast<int>(midiInGetNumDevs());

	if (source_index < 0 || source_index >= num_devices) {
		return nullptr;
	}

	auto midi_lib = reinterpret_cast<EzmidiWindows*>(context);

	MIDIINCAPS source_info;
	midiInGetDevCaps(source_index, &source_info, sizeof(MIDIINCAPS));
	std::string name = source_info.szPname;
	midi_lib->return_data = name;

	return midi_lib->return_data.c_str();
}

Ezmidi_Error ezmidi_connect_source(Ezmidi_Context* context, int source)
{
	auto midi_lib = reinterpret_cast<EzmidiWindows*>(context);

	int source_count = static_cast<int>(midiInGetNumDevs());
	if (source < 0 || source >= source_count) {
		return EZMIDI_ERROR_INVALID_SOURCE;
	}

	close_existing_connection(midi_lib);

	if (midi_lib->config.log_func) {
		std::string error_message = "opening connection to source: " + std::to_string(source);
		midi_lib->config.log_func(error_message.c_str(), midi_lib->config.user_data);
	}

	MMRESULT result = midiInOpen(&midi_lib->input_handle, source, reinterpret_cast<DWORD_PTR>(&windows_midi_in_proc),reinterpret_cast<DWORD_PTR>(midi_lib), CALLBACK_FUNCTION);

	if (result == MMSYSERR_NOERROR) {
		midiInStart(midi_lib->input_handle);

		return EZMIDI_ERROR_NONE;
	}
	else {
		if (midi_lib->config.log_func) {
			std::string error_message = "Windows MM error connecting to source: " + std::to_string(result);
			midi_lib->config.log_func(error_message.c_str(), midi_lib->config.user_data);
		}

		midiInClose(midi_lib->input_handle);

		return EZMIDI_ERROR_CONNECTION_FAILED;
	}
}

Ezmidi_Error ezmidi_disconnect_source(Ezmidi_Context* context)
{
	auto midi_lib = reinterpret_cast<EzmidiWindows*>(context);

	return close_existing_connection(midi_lib);
}

int ezmidi_has_source_connected(Ezmidi_Context* context)
{
	auto midi_lib = reinterpret_cast<EzmidiWindows*>(context);
	return midi_lib->input_handle != NULL;
}

int ezmidi_get_next_event(Ezmidi_Context* context, Ezmidi_Event* event)
{
	auto midi_lib = reinterpret_cast<EzmidiWindows*>(context);

	if (event)
		return midi_lib->message_processor.getNextEvent(*event);
	else
		return 0;
}
#endif

#ifdef __APPLE__

// **********
// coremidi.cpp
// **********

#include <CoreMIDI/MIDIServices.h>
#include <iostream>
#include <string>
#include <sstream>

// MRL 05/09/2019
// Note that there appears to be a bug when calling MIDIClientCreate from within a bundle
// The method can potentially fail with an error code of -50.
// Discussion from RtMidi issue page: https://github.com/thestk/rtmidi/issues/155
// Workaround is to open MIDIMonitor in the background before calling MIDIClientCreate from bundle: https://www.snoize.com/MIDIMonitor/

struct EzmidiCoreMidi {
	MIDIClientRef midi_client = 0;
	ezmidi::MessageProcessor message_processor;
    std::string return_data;
    Ezmidi_Config config;
};

void midiReadProc(const MIDIPacketList* packetList, void* refCon, void* srcConnRefCon)
{
	auto* coremidi = reinterpret_cast<EzmidiCoreMidi*>(refCon);
	
	MIDIPacket *packet = (MIDIPacket*)packetList->packet;

	for (int i = 0; i < packetList->numPackets; i++) {
        coremidi->message_processor.processMidiMessage(packet->data);

		packet = MIDIPacketNext(packet);
	}
	
}

// Disposing of a midi client will also clean up all it's ports.
Ezmidi_Error close_existing_connection(EzmidiCoreMidi* coremidi)
{
	if (coremidi->midi_client) {
		if (coremidi->config.log_func) {
			coremidi->config.log_func("closing existing connection", coremidi->config.user_data);
		}

		MIDIClientDispose(coremidi->midi_client);
		coremidi->midi_client = 0;

		return EZMIDI_ERROR_NONE;
	}
	else {
		return EZMIDI_ERROR_NO_SOURCE_CONNECTED;
	}
}

Ezmidi_Error ezmidi_disconnect_source(Ezmidi_Context* context)
{
	auto* coremidi = reinterpret_cast<EzmidiCoreMidi*>(context);

	return close_existing_connection(coremidi);
}

Ezmidi_Error coremidi_error(EzmidiCoreMidi* coremidi, const char* method, OSStatus status, Ezmidi_Error error)
{
    if (coremidi->config.log_func) {
        std::ostringstream s;
        s << method << " failed: " << status;
        coremidi->config.log_func(s.str().c_str(), coremidi->config.user_data);
    }

	close_existing_connection(coremidi);

	return error;
}


Ezmidi_Context* ezmidi_create(Ezmidi_Config* config)
{
	auto* coremidi = new EzmidiCoreMidi();
    if (config)
        coremidi->config = *config;
    else
        ezmidi_config_init(&coremidi->config);
	
	return reinterpret_cast<Ezmidi_Context*>(coremidi);
}

int ezmidi_has_source_connected(Ezmidi_Context* context)
{
	auto* coremidi = reinterpret_cast<EzmidiCoreMidi*>(context);

	return coremidi->midi_client != 0;
}

void ezmidi_destroy(Ezmidi_Context* context)
{
	auto* coremidi = reinterpret_cast<EzmidiCoreMidi*>(context);
    close_existing_connection(coremidi);
	
	delete coremidi;
}

int ezmidi_get_source_count(Ezmidi_Context* context)
{
	return MIDIGetNumberOfSources();
}

std::string get_source_property(MIDIEndpointRef midi_source, CFStringRef property_name)
{
	CFStringRef cf_string;
	char property_buffer[64];
	MIDIObjectGetStringProperty(midi_source, property_name, &cf_string);
	CFStringGetCString(cf_string, property_buffer, sizeof(property_buffer), 0);
	CFRelease(cf_string);
	
	return std::string(property_buffer);
}

const char* ezmidi_get_source_name(Ezmidi_Context* context, int source_index)
{
	int source_count = MIDIGetNumberOfSources();
	if (source_index < 0 || source_index >= source_count)
		return nullptr;
	
	auto* coremidi = reinterpret_cast<EzmidiCoreMidi*>(context);
	MIDIEndpointRef midi_source = MIDIGetSource(source_index);
    
    std::string manufacturer = get_source_property(midi_source, kMIDIPropertyManufacturer);
	std::string model = get_source_property(midi_source, kMIDIPropertyModel);
    
    std::string result = manufacturer;
    if (!model.empty()) {
        if (!result.empty())result.append(" ");
        result.append(model);
    }
    
    if (!result.empty()) {
        coremidi->return_data = result;
    }
    else {
        coremidi->return_data = get_source_property(midi_source, kMIDIPropertyModel);
    }
	return coremidi->return_data.c_str();
}

Ezmidi_Error ezmidi_connect_source(Ezmidi_Context* context, int source)
{
	auto* coremidi = reinterpret_cast<EzmidiCoreMidi*>(context);

    if (source < 0 || source >= MIDIGetNumberOfSources()) {
        return EZMIDI_ERROR_INVALID_SOURCE;
    }
    
    close_existing_connection(coremidi);
    
    if (coremidi->config.log_func) {
        coremidi->config.log_func("opening connection", coremidi->config.user_data);
    }
    
    OSStatus error = MIDIClientCreate(CFSTR("coremidi_client"), nullptr, nullptr, &coremidi->midi_client);
    if (error) {
        return coremidi_error(coremidi, "MIDIClientCreate", error, EZMIDI_ERROR_CONNECTION_FAILED);
    }
    
	MIDIPortRef midi_port = 0;
    error = MIDIInputPortCreate(coremidi->midi_client, CFSTR("coremidi_port"), midiReadProc, coremidi, &midi_port);
    if (error) {
        return coremidi_error(coremidi, "MIDIInputPortCreate", error, EZMIDI_ERROR_CONNECTION_FAILED);
    }
	
	MIDIEndpointRef midi_source = MIDIGetSource(source);
	
	if (midi_source != 0) {
		error = MIDIPortConnectSource(midi_port, midi_source, nullptr);
        if (error) {
			return coremidi_error(coremidi, "MIDIPortConnectSource", error, EZMIDI_ERROR_CONNECTION_FAILED);
		}
	}
	else {
		return coremidi_error(coremidi, "MIDIGetSource", error, EZMIDI_ERROR_CONNECTION_FAILED);
	}
	
	return EZMIDI_ERROR_NONE;
}

int ezmidi_get_next_event(Ezmidi_Context* context, Ezmidi_Event* event)
{
	if (!event) return 0;
	auto* coremidi = reinterpret_cast<EzmidiCoreMidi*>(context);

	return coremidi->message_processor.getNextEvent(*event);
}

#endif

#ifdef __linux__

// **********
// alsa.cpp
// **********

#include <alsa/asoundlib.h>

#include <vector>
#include <string>
#include <thread>
#include <atomic>
#include <iostream>
#include <chrono>
#include <cstdint>

struct EzmidiAlsa
{
    snd_rawmidi_t* midi_input = nullptr;
    Ezmidi_Config config;
    ezmidi::MessageProcessor message_processor;
    std::thread input_thread;
    std::atomic_bool process_input;
    std::string return_data;
};

using SourceDeviceVector = std::vector<std::pair<std::string, std::string>>;
SourceDeviceVector get_source_device_info();


Ezmidi_Context* ezmidi_create(Ezmidi_Config* config)
{
    auto ezmidi_alsa = new EzmidiAlsa{};
    ezmidi_alsa->process_input = false;

    if (config) {
        ezmidi_alsa->config = *config;
    }
    else {
        ezmidi_config_init(&ezmidi_alsa->config);
    }

    return reinterpret_cast<Ezmidi_Context*>(ezmidi_alsa);
}

Ezmidi_Error close_active_connection(EzmidiAlsa* ezmidi_alsa)
{
	if (ezmidi_alsa->midi_input) {
		ezmidi_alsa->process_input = false;

		if (ezmidi_alsa->input_thread.joinable()) {
			ezmidi_alsa->input_thread.join();
		}

		snd_rawmidi_close(ezmidi_alsa->midi_input);
		ezmidi_alsa->midi_input = nullptr;

		return EZMIDI_ERROR_NONE;
	}

	return EZMIDI_ERROR_NO_SOURCE_CONNECTED;
}

void ezmidi_destroy(Ezmidi_Context* context)
{
    auto ezmidi_alsa = reinterpret_cast<EzmidiAlsa*>(context);

	close_active_connection(ezmidi_alsa);

    delete ezmidi_alsa;
}

int ezmidi_get_source_count(Ezmidi_Context* /* context */)
{
    SourceDeviceVector devices = get_source_device_info();

    return static_cast<int>(devices.size());
}

const char* ezmidi_get_source_name(Ezmidi_Context* context, int source_index)
{
    auto ezmidi_alsa = reinterpret_cast<EzmidiAlsa*>(context);

    if (source_index >= 0) {
        SourceDeviceVector devices = get_source_device_info();

        if (source_index < devices.size()) {
            ezmidi_alsa->return_data = devices[source_index].second;

            return ezmidi_alsa->return_data.c_str();
        }
    }

    return nullptr;
}

void alsa_input_thread(EzmidiAlsa *ezmidi_alsa)
{
    ezmidi_alsa->process_input = true;

    uint8_t buffer[256] = {0};

    while (ezmidi_alsa->process_input) {
        int status = 0;

        while (status != -EAGAIN) {
            status = snd_rawmidi_read(ezmidi_alsa->midi_input, buffer, 256);

            if (status > 0) {
				ezmidi_alsa->message_processor.processMidiMessage(buffer);
            }
        }

        std::this_thread::sleep_for(std::chrono::milliseconds(1));
    }
}

Ezmidi_Error ezmidi_connect_source(Ezmidi_Context* context, int source)
{
    auto ezmidi_alsa = reinterpret_cast<EzmidiAlsa*>(context);

    int open_mode = SND_RAWMIDI_NONBLOCK;
    SourceDeviceVector devices = get_source_device_info();
	if (source < 0 || source >= devices.size()) {
		return EZMIDI_ERROR_INVALID_SOURCE;
	}
	
    int status = snd_rawmidi_open(&ezmidi_alsa->midi_input, NULL, devices[source].first.c_str(), open_mode);
	
	if (status < 0) {
		return EZMIDI_ERROR_CONNECTION_FAILED;
	}

    ezmidi_alsa->input_thread = std::thread(alsa_input_thread, ezmidi_alsa);
	
	return EZMIDI_ERROR_NONE;
}

Ezmidi_Error ezmidi_disconnect_source(Ezmidi_Context* context)
{
	auto ezmidi_alsa = reinterpret_cast<EzmidiAlsa*>(context);
	
	return close_active_connection(ezmidi_alsa);
}

int ezmidi_has_source_connected(Ezmidi_Context* context)
{
	auto ezmidi_alsa = reinterpret_cast<EzmidiAlsa*>(context);

	return ezmidi_alsa->midi_input != nullptr;
}

int ezmidi_get_next_event(Ezmidi_Context* context, Ezmidi_Event* event)
{
    if (event) {
        auto ezmidi_alsa = reinterpret_cast<EzmidiAlsa*>(context);

        return ezmidi_alsa->message_processor.getNextEvent(*event);
    }

    return 0;
}

SourceDeviceVector get_source_device_info()
{
    SourceDeviceVector input_device_info;

    int card = -1;
    snd_card_next(&card);

    while (card >= 0) {
        snd_ctl_t *ctl;
        int device = -1;

        char sound_card_handle[32];
        snprintf(sound_card_handle, 32, "hw:%d", card);
        snd_ctl_open(&ctl, sound_card_handle, 0);

        snd_ctl_rawmidi_next_device(ctl, &device);

        while (device >= 0) {
            snd_rawmidi_info_t *info;
            int input_subdevices = 0;
            const char *sub_name;

            snd_rawmidi_info_alloca(&info);
            snd_rawmidi_info_set_device(info, device);

            snd_rawmidi_info_set_stream(info, SND_RAWMIDI_STREAM_INPUT);
            snd_ctl_rawmidi_info(ctl, info);
            input_subdevices = snd_rawmidi_info_get_subdevices_count(info);

            for (int subdevice = 0; subdevice < input_subdevices; subdevice++) {
                snd_rawmidi_info_set_subdevice(info, subdevice);

                if (snd_ctl_rawmidi_info(ctl, info) == 0) {
                    char subdevice_handle[32];
                    snprintf(subdevice_handle, 32, "hw:%d,%d,%d", card, device, subdevice);
                    sub_name = snd_rawmidi_info_get_subdevice_name(info);

                    input_device_info.emplace_back(std::make_pair(subdevice_handle, sub_name));
                }
            }

            snd_ctl_rawmidi_next_device(ctl, &device);
        }

        snd_ctl_close(ctl);
        snd_card_next(&card);
    }

    return input_device_info;
}

#endif

#endif
